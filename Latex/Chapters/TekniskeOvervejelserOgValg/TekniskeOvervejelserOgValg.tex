	%!TEX root = ../../Main.tex
\graphicspath{{Chapters/Alternative/}}
%-------------------------------------------------------------------------------


\section{Tekniske overvejelse og valg}


Da projektets omfang og opbygning har været meget frit, er der også blevet lavet nogle valg og fravalg i process fasen. Dette gives der et overblik over i dette afsnit, samt at forklare fordele og ulmeper ved hvert modul vi har valgt og driverne dertil. 

\subsection{TFT Display} 
Da omfanget for projektet inkluderede et display, gjorde gruppen et valg om at bruge TJC-9341-032 som display, og \href{https://blackboard.au.dk/bbcswebdav/pid-1697983-dt-content-rid-3847230_1/courses/BB-Cou-UUVA-73302/BB-Cou-UUVA-65758_ImportedContent_20170106021228/BB-Cou-STADS-UUVA-52360_ImportedContent_20160107025559/LAB/Lab3a%20Graphic%20LCD%20Display/Files%20for%20LAB3a/ILI9341_v1.11.pdf}{ILI9341} 
som display controller. Dette \href{https://blackboard.au.dk/bbcswebdav/pid-1697983-dt-content-rid-3847230_1/courses/BB-Cou-UUVA-73302/BB-Cou-UUVA-65758_ImportedContent_20170106021228/BB-Cou-STADS-UUVA-52360_ImportedContent_20160107025559/LAB/Lab3a%20Graphic%20LCD%20Display/Files%20for%20LAB3a/ILI9341_v1.11.pdf}{ILI9341} 
er valgt på baggrund af, at gruppen har abejdet med dette display modul tidligere, derudover var dette også tilgængeligt.
Til selve display'et er der valgt kun at kunne skrive til display'et og ikke læse fra det. Fordelen ved kun at sende data til displayet, er at det gør opsætningen meget nemmere for udvikleren. \\
Fordelen ved at intialisere driveren til at kunne modtage data fra displayet, ville være at programstrukturen, kunne spørge skærmen hvilket display, der var på skærmen nu. Dette vil sikre at programstrukturen altid ved hvilket frame der vises på displayet. Ulempen ved den måde gruppen har intialiseret driveren på, er at microcontroller skal holde styr på hvilken frame, der vises på skærmen. Dette gør det mere udfordrende for udvikleren, og derved gør at koden kommer til at fylde mere. Hvis driveren skulle laves på en memory kritisk microcontroller, ville det være en fordel at tilføje skærmen at kunne læse hvilket frame der står på skærmen. \\
Vi har ikke brugt meget tid på at undersøge alternative display. Der blev valgt at et Alphanumeric display, som tidligere var bearbejdet, ikke ville opfylde de krav vi havde til displayet, og da controller shielded, ITDB02, havde en Touch controller del, blev Alphanumeric display'et valgt fra.

\subsection{Brug af globale variabler}
Igennem de forskellige drivere gøres der brug af globale variabler. Dette er gjort for at simplificire udviklingen af driverne. Denne programmerings-praksis er dog lidt ilde set på og er generelt ikke god programmerings-skik. Dette ville blive prioritetet ved fremtidigt arbejde, således at disse globale variabler ville blive erstattet med get() og set() metoder. 

\subsection{Bluetooth Modul}
De første uger af udviklingsperioden var der i gruppen større problemer med det Bluetooth modul der først var blevet lånt af \href{https://stockmanager.ase.au.dk/}{Embedded Stock} til implementering i systemet. Efter en uges tid med troubleshooting og debugging på hvorfor den ikke kunne sættes op til at søge efter andre enheder, viste det sig at det udleverede modul ikke var det rigtige modul som gruppen oprindeligt havde bestilt. Der var blevet bestilt et HC-05 modul, men istedet udleveret et HC-06 modul. Forskellen kan ikke ses med det blotte øje, da modulerne fysisk er ens og den eneste reele forskel er firmwaren den er blevet sendt afsted med fra fabrikken. HC-06 firmwaren er meget mere simpelt bygget op og understøtter derfor ikke samme antal avancerede AT-kommandoer. Dermed kan den ikke initialiseres til at kunne søge efter andre enheder og dermed lave inquiries.

Herefter blev der lånt et anderledes HC-05 med et større breakout-board, hvilket efter nogle få timers debugging og troubleshooting måtte konkluderes at være i stykker. Det lykkedes dog igennem Embedded Stock at få lånt et nyt HC-05 modul med et anderledes breakout-board. Dette var funktionelt og endelig kunne gruppen begynde på selve implementeringen af Bluetooth-modulet i systemet, som inkluderer alle de funktioner den skal kunne understøtte fra Arduino'en. Der var dog også snak om hvorvidt gruppen skulle bestille et dyrere Bluetooth-modul på Amazon, men i og med vi først fik prøvet det andet af, kunne gruppen konstatere at det fint ville fungerere i sammenhæng med resten af systemet. Yderlige havde gruppen på dette tidspunkt ikke behov for flere forsinkelser med Bluetooth-moduler og derfor var der ikke incitament for at skulle vente på at posten ville nå frem.

Den benyttede Bluetooth-modul i systemet, som kan ses på figur \ref{fig:bluetooth_modul}, er dog anderledes bygget op på breakout-boardet, hvilket betyder, at der har skulle træffes nogle valg alt efter, hvordan gruppen ville bruge Bluetooth-modulet i systemet. Bluetooth-modulet har 2 muligheder: den kan styres af kommandoer igennem Bluetooth-protokolen OTA (over-the-air) af enheder den har oprettet en Bluetooth forbindelse til og så kan man styre den ved brug af UART forbindelse og AT-kommandoer til dens RX/TX ben.

\subsection{Touch.c og countingmillis.c}
Da tiden var knap, blev TouchRead funktionen implementeret i main. Denne funtionalitet og derved styring af input fra brugeren, ville i et færdig produkt skulle ligge i SystemMaster. Derudover blev der taget et valg om at indsætte et delay på 100 mikrosekunder, for at sikre at systemet ikke registreret et "dobbelttryk" fra brugeren når man bruger touch displayet. En smartere måde at sikre dette på var ved at introducere et interrupt som først triggerede når brugeren trykkede på skærmen. Det føromtalte delay, blev derudover brugt til at opdatere systemet hver 5. sekund. Dette kunne også gøres smartere, da vi ikke rammer præcis 5 sekunder, da de forskellige instuktioner som sker under delay ikke er talt med. Dette kunne være løst med klassen counting\_millis, som blev lavet på baggrund af tidligere brug af funktionen millis() i Arduino's IDE. Denne funtion introducerer en realtids timer til systemet, så timingen bliver præcis 5 sekunder. Denne funktion gjorde dog brug af interrupt, som forstyrrede resten af systemet.   
